# 疑问：

1. 为什么要用这个init

# C++基础知识补充：

1. namespace的用处
2. 虚函数与纯虚函数的区别与用处
3. C++异常规格说明(Exception specifications) [用法解析](https://blog.csdn.net/small_prince_/article/details/80560944)
4. C++定义一个class,如果成员变量没有说明是共有还是私有，那么默认是protect; 同样的，struct是public
# 程序重点笔记

1. Exception.cpp,line 11: m_message = strdup(message); 因为无法确保message的生命周期 ，所以拷贝一份message进行赋值， 拷贝到了堆空间上。

2. 纯虚函数通常是不需要提供函数函数实现的，但是**有个例外**，就是纯虚的析构函数，因为C++规定，只要自定义了析构函数，不管是不是纯虚函数，必须提供函数实现

3. 自定义顶层父类的意义： 不同编译器有对C++的不同编译标准，不同的编译，对new失败后的做法不同，所以，为了代码库兼容所有的平台，那么需要自定义new行为。（总结：遵循经典设计准则，所有数据结构都继承自Object类；定义动态内存申请行为，提高代码的移植性）

4. private, protect, public 区别：
    1. 公有继承(public)：公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。

    2. 私有继承(private)：私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。

    3. 保护继承(protected)：保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。

5. mutable的应用：在LinkList.h里面有个很特别的设计，就是通常来讲，get函数只获取元素，不修改元素，所以会在函数末尾加一个const进行修饰，但是，我们需要对成员变量m_header进行&操作，C++编译器认为&会修改成员变量，所以报错，这里的解决方案就是，使用mutable对m_header进行修饰

# 数据结构分析：

+ 顺序表：
    + 优点：高效遍历
    + 缺点：低效插入，删除

+ 单链表：
    + 优点：高效插入，删除，但是频繁的插入和删除会导致系统内存碎片化
    + 缺点：低效遍历

+ 静态单链表：
    + 顺序表 + 单链表 = 静态单链表
    + 应用场景： 最大元素个数固定，而且要进行频繁得增删数据元素的场合；单链表频繁的插入和删除会导致系统内存碎片化，久而久之导致系统需要从新管理内存，从而影响程序运行速度。为了解决这个问题，提出静态单链表的概念。

# 讲师工程经验：

+ 尽量使用单重继承的方式进行系统设计

+ 尽量保持系统中只存在单一的继承树

+ 尽量使用组合关系代替继承关系